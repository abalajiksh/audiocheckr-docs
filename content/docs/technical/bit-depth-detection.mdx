---
title: Bit Depth Detection
description: Multi-method algorithm for detecting fake 24-bit audio files
---

# Bit Depth Detection

AudioCheckr uses four independent methods to detect "fake" 24-bit audio—files that claim to be 24-bit but actually contain 16-bit audio with zero-padded lower bits.

## The Problem: Fake 24-Bit Audio

When 16-bit audio is converted to 24-bit format without proper dithering, the lower 8 bits are simply padded with zeros. This provides no quality improvement—just larger file sizes.

### How 16-to-24 Bit Upscaling Works

**Original 16-bit sample:**
```
Binary: XXXXXXXX XXXXXXXX (16 bits of actual data)
Decimal range: -32768 to +32767
```

**After padding to 24-bit:**
```
Binary: XXXXXXXX XXXXXXXX 00000000 (16 bits + 8 zero bits)
Decimal range: -8388608 to +8388607 (but only 65536 unique values)
```

### The Key Insight

- **Genuine 24-bit**: Lower 8 bits contain random data (dither noise, recording noise, or actual signal)
- **Fake 24-bit**: Lower 8 bits are always `00000000` or `10000000` (zero-padded)

---

## Method 1: LSB Precision Analysis

### Theory

In genuine 24-bit audio, the distribution of trailing zeros in sample values should be relatively random. In fake 24-bit audio (upscaled from 16-bit), nearly all samples will have exactly 8 trailing zeros.

### Algorithm

```rust
fn analyze_lsb_precision(samples: &[f32]) -> (u32, f32) {
    let test_samples = samples.len().min(200000);
    
    let mut trailing_zero_counts: HashMap<u32, u32> = HashMap::new();
    let mut total_samples = 0u32;
    
    for &sample in samples.iter().take(test_samples) {
        // Skip near-silence (these naturally have many trailing zeros)
        if sample.abs() < 1e-5 {
            continue;
        }
        
        // Scale to 24-bit integer range
        let scaled = (sample * 8388607.0).round() as i32;
        
        if scaled != 0 {
            // Count trailing zeros (0-24)
            let trailing = scaled.trailing_zeros().min(24);
            *trailing_zero_counts.entry(trailing).or_insert(0) += 1;
            total_samples += 1;
        }
    }
    
    // Analyze distribution
    let samples_with_exactly_8 = *trailing_zero_counts.get(&8).unwrap_or(&0);
    let ratio_exactly_8 = samples_with_exactly_8 as f32 / total_samples as f32;
    
    let samples_with_8plus: u32 = trailing_zero_counts.iter()
        .filter(|(&zeros, _)| zeros >= 8)
        .map(|(_, &count)| count)
        .sum();
    let ratio_8plus = samples_with_8plus as f32 / total_samples as f32;
    
    let samples_with_low_zeros: u32 = trailing_zero_counts.iter()
        .filter(|(&zeros, _)| zeros <= 3)
        .map(|(_, &count)| count)
        .sum();
    let ratio_low_zeros = samples_with_low_zeros as f32 / total_samples as f32;
    
    // Decision logic with conservative thresholds
    if ratio_exactly_8 > 0.95 && ratio_low_zeros < 0.02 {
        (16, 0.95)  // Definitely 16-bit upscaled
    } else if ratio_8plus > 0.90 && ratio_low_zeros < 0.05 {
        (16, 0.85)  // Very likely 16-bit
    } else if ratio_low_zeros > 0.30 {
        (24, 0.90)  // Significant activity in lower bits
    } else if ratio_low_zeros > 0.15 {
        (24, 0.75)  // Some activity in lower bits
    } else {
        (24, 0.60)  // Default to 24-bit (avoid false positives)
    }
}
```

### Trailing Zero Distribution

| Scenario | 0-3 zeros | 4-7 zeros | 8 zeros | 9+ zeros |
|----------|-----------|-----------|---------|----------|
| Genuine 24-bit | ~40% | ~30% | ~5% | ~25% |
| Fake 24-bit (16→24) | ~0% | ~0% | **~95%** | ~5% |

### Why 8 Trailing Zeros?

When a 16-bit value is shifted to 24-bit position:

```
16-bit: 0x1234 (example value)
24-bit: 0x123400 (shifted left 8 bits)

Binary: ... XXXX XXXX 0000 0000
                      ^^^^^^^^
                      8 trailing zeros
```

---

## Method 2: Histogram Analysis

### Theory

Genuine 24-bit audio has ~16.7 million possible values. Fake 24-bit audio (from 16-bit) has only ~65,536 unique values, and these values cluster on 256-boundaries.

### Algorithm

```rust
fn analyze_histogram(samples: &[f32]) -> (u32, f32) {
    let test_samples = samples.len().min(200000);
    
    let mut values_16bit: HashMap<i32, u32> = HashMap::new();
    let mut values_24bit: HashMap<i32, u32> = HashMap::new();
    
    for &sample in samples.iter().take(test_samples) {
        if sample.abs() < 1e-5 {
            continue;  // Skip silence
        }
        
        // Quantize to both bit depths
        let q16 = (sample * 32767.0).round() as i32;
        let q24 = (sample * 8388607.0).round() as i32;
        
        *values_16bit.entry(q16).or_insert(0) += 1;
        *values_24bit.entry(q24).or_insert(0) += 1;
    }
    
    let unique_16 = values_16bit.len();
    let unique_24 = values_24bit.len();
    
    // Ratio of unique values at each quantization
    let ratio = unique_24 as f32 / unique_16.max(1) as f32;
    
    // Check for 256-boundary clustering
    let multiples_of_256: usize = values_24bit.keys()
        .filter(|&&v| v != 0 && v.abs() % 256 == 0)
        .count();
    let boundary_ratio = multiples_of_256 as f32 / unique_24.max(1) as f32;
    
    // Decision logic
    if ratio < 1.2 && boundary_ratio > 0.85 {
        (16, 0.95)  // Almost certainly 16-bit
    } else if ratio < 1.5 && boundary_ratio > 0.70 {
        (16, 0.80)
    } else if ratio > 100.0 {
        (24, 0.95)  // Massive increase in unique values
    } else if ratio > 20.0 {
        (24, 0.85)
    } else {
        (24, 0.50)  // Inconclusive
    }
}
```

### Unique Value Ratios

| Audio Type | Unique 16-bit values | Unique 24-bit values | Ratio |
|------------|---------------------|---------------------|-------|
| Genuine 24-bit | ~10,000 | ~500,000+ | **50-100+** |
| Fake 24-bit | ~10,000 | ~10,000 | **~1.0** |

### 256-Boundary Clustering

When 16-bit is scaled to 24-bit:

$$
\text{24-bit value} = \text{16-bit value} \times 256
$$

All values land on multiples of 256:
- `0x0001` → `0x000100`
- `0x0002` → `0x000200`
- `0x00FF` → `0x00FF00`

---

## Method 3: Quantization Noise Analysis

### Theory

The noise floor of audio reveals its true bit depth. 16-bit audio has a theoretical noise floor of -96 dB, while 24-bit extends to -144 dB.

More importantly, the **step size** between adjacent quantization levels differs:

| Bit Depth | Step Size (normalized) | In dB |
|-----------|----------------------|-------|
| 16-bit | 1/32768 ≈ 3.05e-5 | -90.3 dB |
| 24-bit | 1/8388608 ≈ 1.19e-7 | -138.5 dB |

### Algorithm

```rust
fn analyze_quantization_noise(samples: &[f32]) -> (u32, f32) {
    let section_size = 16384;
    let num_sections = (samples.len() / section_size).min(20);
    
    // Find quiet sections (not silence, but low level)
    let mut quiet_sections: Vec<(usize, f32)> = Vec::new();
    
    for i in 0..num_sections {
        let start = i * section_size;
        let section = &samples[start..start + section_size];
        
        let rms = (section.iter().map(|s| s * s).sum::<f32>() 
                  / section.len() as f32).sqrt();
        
        // Look for quiet but not silent sections
        if rms > 1e-7 && rms < 0.01 {
            quiet_sections.push((start, rms));
        }
    }
    
    if quiet_sections.is_empty() {
        return (24, 0.40);  // Can't analyze
    }
    
    // Sort by quietness
    quiet_sections.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());
    
    // Analyze sample-to-sample differences in quiet sections
    let mut lsb_noise_sum = 0.0f32;
    let mut count = 0;
    
    for (start, _) in quiet_sections.iter().take(5) {
        let section = &samples[*start..*start + section_size];
        
        let diffs: Vec<f32> = section.windows(2)
            .map(|w| (w[1] - w[0]).abs())
            .filter(|&d| d > 1e-10 && d < 0.001)
            .collect();
        
        if diffs.len() > 100 {
            let mut sorted_diffs = diffs.clone();
            sorted_diffs.sort_by(|a, b| a.partial_cmp(b).unwrap());
            
            // 10th percentile as estimate of minimum step
            let noise_step = sorted_diffs[sorted_diffs.len() / 10];
            lsb_noise_sum += noise_step;
            count += 1;
        }
    }
    
    if count == 0 {
        return (24, 0.40);
    }
    
    let avg_noise_step = lsb_noise_sum / count as f32;
    
    // Compare to expected step sizes
    let step_16bit = 1.0 / 32768.0;   // ~3.05e-5
    let step_24bit = 1.0 / 8388608.0; // ~1.19e-7
    
    if avg_noise_step > step_16bit * 0.7 {
        (16, 0.80)  // Matches 16-bit quantization
    } else if avg_noise_step < step_24bit * 50.0 {
        (24, 0.85)  // Very fine noise floor
    } else if avg_noise_step < step_16bit * 0.2 {
        (24, 0.70)  // Finer than 16-bit allows
    } else {
        (24, 0.45)  // Inconclusive
    }
}
```

### Noise Floor Visualization

```
Amplitude
    │
    │  ────────────────────── 16-bit noise floor (~-96 dB)
    │
    │
    │
    │  ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─  24-bit noise floor (~-144 dB)
    │
    └──────────────────────────────────────
                                      Time
```

---

## Method 4: Value Clustering Analysis

### Theory

In genuine 24-bit audio, the lower 8 bits (LSBs) should have a relatively uniform distribution—high entropy. In fake 24-bit audio, the LSBs cluster at `0x00` and `0x80` (the result of sign extension).

### Entropy Calculation

Shannon entropy measures the randomness of a distribution:

$$
H = -\sum_{i=0}^{255} p_i \cdot \log_2(p_i)
$$

Where $p_i$ is the probability of LSB value $i$.

- **Maximum entropy**: 8 bits (uniform distribution over 256 values)
- **Zero entropy**: All samples have the same LSB

### Algorithm

```rust
fn analyze_value_clustering(samples: &[f32]) -> (u32, f32) {
    let test_samples = samples.len().min(200000);
    let mut lsb_distribution: HashMap<u8, u32> = HashMap::new();
    let mut total_non_silent = 0u32;
    
    for &sample in samples.iter().take(test_samples) {
        if sample.abs() < 1e-5 {
            continue;
        }
        
        let q24 = (sample * 8388607.0).round() as i32;
        let lsb_8 = (q24.abs() & 0xFF) as u8;  // Extract lower 8 bits
        
        *lsb_distribution.entry(lsb_8).or_insert(0) += 1;
        total_non_silent += 1;
    }
    
    let unique_lsb_values = lsb_distribution.len();
    
    // Check concentration at 0x00 and 0x80
    let count_00 = *lsb_distribution.get(&0x00).unwrap_or(&0);
    let count_80 = *lsb_distribution.get(&0x80).unwrap_or(&0);
    let concentrated_ratio = (count_00 + count_80) as f32 / total_non_silent as f32;
    
    // Calculate entropy
    let entropy = calculate_entropy(&lsb_distribution);
    let max_entropy = 8.0;
    let normalized_entropy = entropy / max_entropy;
    
    // Decision logic
    if concentrated_ratio > 0.95 && unique_lsb_values < 5 {
        (16, 0.95)  // Almost all at 0x00/0x80
    } else if concentrated_ratio > 0.85 && unique_lsb_values < 20 {
        (16, 0.85)
    } else if normalized_entropy > 0.90 && unique_lsb_values > 200 {
        (24, 0.95)  // High entropy, many unique values
    } else if normalized_entropy > 0.80 && unique_lsb_values > 150 {
        (24, 0.80)
    } else {
        (24, 0.50)
    }
}

fn calculate_entropy(distribution: &HashMap<u8, u32>) -> f32 {
    let total: u32 = distribution.values().sum();
    if total == 0 {
        return 0.0;
    }
    
    distribution.values()
        .filter(|&&count| count > 0)
        .map(|&count| {
            let p = count as f32 / total as f32;
            -p * p.log2()
        })
        .sum()
}
```

### LSB Distribution Comparison

**Genuine 24-bit** (high entropy):
```
LSB Value:  0   32   64   96  128  160  192  224
Frequency:  ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓ ▓▓▓
            (roughly uniform distribution)
```

**Fake 24-bit** (low entropy):
```
LSB Value:  0   32   64   96  128  160  192  224
Frequency:  ████████████████ ████████████████
            (concentrated at 0x00 and 0x80)
```

---

## Conservative Voting System

The four methods are combined using a weighted voting system that requires strong consensus before flagging a file:

```rust
fn vote_bit_depth_conservative(
    results: &[(u32, f32)],  // (detected_depth, confidence)
    claimed_bit_depth: u32,
) -> (u32, f32) {
    let mut vote_16 = 0.0f32;
    let mut vote_24 = 0.0f32;
    let mut high_confidence_16_count = 0;
    
    for &(bit_depth, confidence) in results {
        if bit_depth <= 16 {
            vote_16 += confidence;
            if confidence >= 0.80 {
                high_confidence_16_count += 1;
            }
        } else {
            vote_24 += confidence;
        }
    }
    
    let total = vote_16 + vote_24;
    if total < 0.1 {
        return (claimed_bit_depth, 0.3);  // No clear signal
    }
    
    // CONSERVATIVE: Require MULTIPLE high-confidence votes
    if vote_16 > vote_24 && high_confidence_16_count >= 3 {
        (16, vote_16 / total)
    } else if vote_16 > vote_24 * 1.5 && high_confidence_16_count >= 2 {
        (16, (vote_16 / total) * 0.9)
    } else if vote_24 > vote_16 {
        (24, vote_24 / total)
    } else {
        (claimed_bit_depth, 0.5)  // Ambiguous - trust claimed
    }
}
```

### Why Conservative?

**False positives are worse than false negatives** for this use case:

- False positive: Genuine 24-bit flagged as fake → User discards good file
- False negative: Fake 24-bit not detected → User keeps unnecessary file

Requirements for flagging as 16-bit:
1. **At least 3** methods with **≥80% confidence**, OR
2. **At least 2** methods with **1.5× vote weight advantage**

### Mismatch Detection

```rust
let is_mismatch = actual_bit_depth == 16 
    && audio.claimed_bit_depth >= 24
    && confidence >= 0.85;  // High threshold
```

Only flag as mismatch if:
- Detected as 16-bit
- File claims 24-bit (or higher)
- Overall confidence ≥85%

---

## Handling Edge Cases

### Dithered Audio

Proper 16-to-24 conversion adds dither noise to the lower bits. This can mask the upscaling:

**Without dither (detectable):**
```
Lower 8 bits: 00000000 00000000 00000000 00000000
```

**With dither (harder to detect):**
```
Lower 8 bits: 01011101 10010110 11100011 00101110
```

AudioCheckr handles this by:
1. Checking if the "noise" is truly random (high entropy)
2. Looking for subtle patterns in the dither
3. Reducing confidence when dither is suspected

### Quiet Recordings

Very quiet recordings may naturally have many zero LSBs. AudioCheckr:
1. Skips near-silence samples
2. Focuses on sections with moderate signal level
3. Reduces confidence for very quiet files

### Mixed Bit Depth

Some files may have mixed content (e.g., 16-bit source with 24-bit effects). AudioCheckr:
1. Analyzes the predominant pattern
2. Reports the most likely original bit depth
3. Notes uncertainty in evidence

---

## Complete Analysis Flow

```rust
pub fn analyze_bit_depth(audio: &AudioData) -> BitDepthAnalysis {
    let samples = &audio.samples;
    
    // Run all four methods
    let lsb_result = analyze_lsb_precision(samples);
    let histogram_result = analyze_histogram(samples);
    let noise_result = analyze_quantization_noise(samples);
    let clustering_result = analyze_value_clustering(samples);
    
    // Combine with conservative voting
    let (actual_bit_depth, confidence) = vote_bit_depth_conservative(
        &[lsb_result, histogram_result, noise_result, clustering_result],
        audio.claimed_bit_depth,
    );
    
    // Check for mismatch
    let is_mismatch = actual_bit_depth == 16 
        && audio.claimed_bit_depth >= 24
        && confidence >= 0.85;
    
    BitDepthAnalysis {
        claimed_bit_depth: audio.claimed_bit_depth,
        actual_bit_depth,
        confidence,
        is_mismatch,
        method_results: BitDepthMethodResults {
            lsb_method: lsb_result.0,
            histogram_method: histogram_result.0,
            noise_method: noise_result.0,
            clustering_method: clustering_result.0,
        },
        evidence: build_evidence(...),
    }
}
```

---

## Summary

| Method | What It Checks | Strength |
|--------|---------------|----------|
| LSB Precision | Trailing zeros in samples | Very reliable for upscaled files |
| Histogram | Unique value count & clustering | Catches value distribution anomalies |
| Quantization Noise | Noise floor characteristics | Works on quiet sections |
| Value Clustering | Lower 8-bit entropy | Entropy-based validation |

The combination of four methods with conservative voting ensures:
- **High precision**: Few false positives
- **Good recall**: Catches most fake 24-bit files
- **Robustness**: Any single method can fail, but consensus is reliable
