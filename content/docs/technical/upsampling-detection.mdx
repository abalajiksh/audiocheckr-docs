---
title: Upsampling Detection
description: Algorithms for detecting audio that has been upsampled from lower sample rates
---

# Upsampling Detection

Upsampling is the process of increasing an audio file's sample rate (e.g., converting 44.1kHz to 96kHz). While this creates a "high-resolution" file, it doesn't add any new information—the high frequencies are simply interpolated.

## The Problem: Fake High-Resolution Audio

### What Happens During Upsampling

When 44.1kHz audio is upsampled to 96kHz:

1. **Original**: 44,100 samples per second, Nyquist = 22.05kHz
2. **Upsampled**: 96,000 samples per second, Nyquist = 48kHz
3. **Reality**: No genuine content above 22.05kHz

The interpolation algorithm creates new samples between the original ones, but it cannot create genuine high-frequency content that wasn't in the source.

### Visual Representation

```
Original 44.1kHz:        Upsampled to 96kHz:
                         
○   ○   ○   ○   ○       ○ · · ○ · · ○ · · ○ · · ○
                         
(actual samples)         (○=original, ·=interpolated)
```

The interpolated samples are mathematically derived from the original samples—they contain no new information.

---

## Detection Methods

AudioCheckr uses multiple methods to detect upsampled audio:

### Method 1: Spectral Null Detection

#### Theory

Upsampled audio has a characteristic "null" or energy void above the original Nyquist frequency. This is because:

1. The original signal had no content above its Nyquist (by definition)
2. Proper upsampling uses a low-pass filter to prevent aliasing
3. This creates a sharp cutoff at the original Nyquist frequency

#### Frequency Relationships

| Original Rate | Original Nyquist | Upsampled To | New Nyquist | Energy Gap |
|--------------|------------------|--------------|-------------|------------|
| 44.1 kHz | 22.05 kHz | 96 kHz | 48 kHz | 22.05-48 kHz |
| 44.1 kHz | 22.05 kHz | 192 kHz | 96 kHz | 22.05-96 kHz |
| 48 kHz | 24 kHz | 96 kHz | 48 kHz | 24-48 kHz |
| 48 kHz | 24 kHz | 192 kHz | 96 kHz | 24-96 kHz |

#### Algorithm

```rust
fn check_spectral_null(samples: &[f32], sample_rate: u32, target_freq: f32) -> bool {
    let nyquist = sample_rate as f32 / 2.0;
    let spectrum = compute_average_spectrum(samples, sample_rate);
    let spectrum_db = to_db_spectrum(&spectrum);
    
    let bin_width = nyquist / spectrum.len() as f32;
    
    // Find energy levels in different frequency bands
    let below_target = average_energy(&spectrum_db, 0.8 * target_freq, target_freq, bin_width);
    let at_target = average_energy(&spectrum_db, target_freq, target_freq * 1.1, bin_width);
    let above_target = average_energy(&spectrum_db, target_freq * 1.1, nyquist * 0.95, bin_width);
    
    // Check for characteristic null pattern:
    // - Good energy below target (original content)
    // - Sharp drop at target (original Nyquist)
    // - Low energy above target (no genuine high-freq content)
    
    let drop_at_target = below_target - at_target;
    let stays_low = at_target - above_target;
    
    // Require significant drop (>20dB) and energy stays low above
    drop_at_target > 20.0 && stays_low.abs() < 10.0
}
```

#### Expected Patterns

**Genuine High-Resolution Audio:**
```
Energy
(dB)  │
      │  ╲
-20   │    ╲                      Content extends
-40   │      ╲___                 to high frequencies
-60   │          ╲___
      │               ╲___
      └─────────────────────────
          22.05kHz    48kHz
```

**Upsampled from 44.1kHz:**
```
Energy
(dB)  │
      │  ╲
-20   │    ╲
-40   │      ╲
-60   │        │________________  Sharp null at
      │        ↑                  original Nyquist
      └─────────────────────────
          22.05kHz    48kHz
              │
              └── Original Nyquist (energy void above)
```

---

### Method 2: Nyquist Mirror Detection

#### Theory

Poor-quality upsampling can create "mirror" artifacts—copies of the original spectrum reflected around the original Nyquist frequency.

#### Mathematical Basis

When upsampling without proper anti-aliasing:

$$
X_{mirror}(f) = X_{original}(2 \cdot f_{N,original} - f)
$$

For example, with 44.1kHz → 96kHz:
- A 20kHz tone might create a mirror at 44.1kHz - 20kHz = 24.1kHz
- A 15kHz tone might create a mirror at 44.1kHz - 15kHz = 29.1kHz

#### Detection

```rust
fn detect_nyquist_mirror(
    samples: &[f32], 
    sample_rate: u32,
    suspected_original_rate: u32
) -> f32 {
    let original_nyquist = suspected_original_rate as f32 / 2.0;
    let spectrum = compute_average_spectrum(samples, sample_rate);
    
    // Compare spectrum below original Nyquist with potential mirror region
    let mut correlation = 0.0f32;
    let bin_width = (sample_rate as f32 / 2.0) / spectrum.len() as f32;
    
    // Check frequency pairs that would be mirrors
    for freq in (1000..original_nyquist as u32).step_by(500) {
        let original_bin = (freq as f32 / bin_width) as usize;
        let mirror_freq = 2.0 * original_nyquist - freq as f32;
        let mirror_bin = (mirror_freq / bin_width) as usize;
        
        if mirror_bin < spectrum.len() {
            // Correlation between original and mirror regions
            correlation += spectrum[original_bin] * spectrum[mirror_bin];
        }
    }
    
    // Normalize and return confidence
    correlation / spectrum.iter().map(|x| x * x).sum::<f32>().sqrt()
}
```

---

### Method 3: Inter-Sample Peak Analysis

#### Theory

Genuine high-resolution audio has significant inter-sample peaks—the signal varies between sample points. Upsampled audio, being interpolated, has smooth transitions and fewer inter-sample peaks.

#### True Peak Measurement

The ITU-R BS.1770 standard defines true peak measurement using 4x oversampling:

```rust
fn analyze_inter_sample_peaks(samples: &[f32], sample_rate: u32) -> f32 {
    // Upsample 4x using sinc interpolation
    let oversampled = upsample_sinc_4x(samples);
    
    let mut inter_sample_peak_count = 0;
    let mut total_peaks = 0;
    
    // Find local maxima in oversampled signal
    for i in 1..oversampled.len() - 1 {
        let is_peak = oversampled[i].abs() > oversampled[i-1].abs() 
                   && oversampled[i].abs() > oversampled[i+1].abs()
                   && oversampled[i].abs() > 0.1;  // Threshold
        
        if is_peak {
            total_peaks += 1;
            // Check if peak falls between original sample positions
            if i % 4 != 0 {
                inter_sample_peak_count += 1;
            }
        }
    }
    
    if total_peaks == 0 {
        return 0.5;  // Inconclusive
    }
    
    // Genuine high-res: many inter-sample peaks
    // Upsampled: peaks mostly at original sample positions
    inter_sample_peak_count as f32 / total_peaks as f32
}
```

#### Sinc Interpolation for 4x Oversampling

```rust
fn upsample_sinc_4x(samples: &[f32]) -> Vec<f32> {
    let filter_len = 16;
    let mut output = vec![0.0f32; samples.len() * 4];
    
    // Place original samples
    for (i, &sample) in samples.iter().enumerate() {
        output[i * 4] = sample;
    }
    
    // Interpolate using windowed sinc
    for i in 0..samples.len() {
        for j in 1..4 {  // Intermediate positions
            let frac = j as f32 / 4.0;
            let out_idx = i * 4 + j;
            
            let mut sum = 0.0f32;
            let mut weight_sum = 0.0f32;
            
            for k in -filter_len..=filter_len {
                let src_idx = i as i32 + k;
                if src_idx >= 0 && (src_idx as usize) < samples.len() {
                    // Sinc function
                    let x = (k as f32 - frac) * PI;
                    let sinc = if x.abs() < 1e-6 { 1.0 } else { x.sin() / x };
                    
                    // Hann window
                    let window = 0.5 * (1.0 + (PI * (k as f32 - frac) / filter_len as f32).cos());
                    
                    let weight = sinc * window;
                    sum += samples[src_idx as usize] * weight;
                    weight_sum += weight.abs();
                }
            }
            
            output[out_idx] = if weight_sum > 0.0 { sum } else { 0.0 };
        }
    }
    
    output
}
```

#### Expected Results

| Audio Type | Inter-Sample Peak Ratio |
|------------|------------------------|
| Genuine 96kHz | 60-75% peaks between samples |
| 44.1kHz → 96kHz | 20-35% peaks between samples |
| 48kHz → 96kHz | 30-45% peaks between samples |

---

### Method 4: Phase Coherence Analysis

#### Theory

The phase relationship between frequency components can reveal upsampling. Genuine high-resolution audio has natural phase variations at high frequencies, while upsampled audio has artificially smooth phase.

#### Implementation

```rust
fn analyze_phase_coherence(samples: &[f32], sample_rate: u32) -> f32 {
    let fft_size = 4096;
    let hop_size = 1024;
    let num_frames = (samples.len() - fft_size) / hop_size;
    
    let mut phase_diffs = Vec::new();
    let mut prev_phase: Option<Vec<f32>> = None;
    
    for i in 0..num_frames.min(50) {
        let start = i * hop_size;
        let frame = &samples[start..start + fft_size];
        
        // Compute FFT
        let spectrum = compute_fft(frame);
        
        // Extract phase
        let phase: Vec<f32> = spectrum.iter()
            .map(|c| c.im.atan2(c.re))
            .collect();
        
        if let Some(prev) = &prev_phase {
            // Phase difference between frames
            for (j, (&curr, &prv)) in phase.iter().zip(prev.iter()).enumerate() {
                // Focus on high frequencies
                if j > fft_size / 4 {
                    let diff = (curr - prv).abs();
                    let wrapped = if diff > PI { 2.0 * PI - diff } else { diff };
                    phase_diffs.push(wrapped);
                }
            }
        }
        
        prev_phase = Some(phase);
    }
    
    if phase_diffs.is_empty() {
        return 0.5;
    }
    
    // High variance = genuine high-freq content
    // Low variance = interpolated (smooth) high frequencies
    let mean = phase_diffs.iter().sum::<f32>() / phase_diffs.len() as f32;
    let variance = phase_diffs.iter()
        .map(|&x| (x - mean).powi(2))
        .sum::<f32>() / phase_diffs.len() as f32;
    
    variance  // Higher = more likely genuine
}
```

---

## Complete Detection Algorithm

```rust
pub fn analyze_upsampling(samples: &[f32], sample_rate: u32) -> UpsamplingAnalysis {
    let mut analysis = UpsamplingAnalysis {
        current_sample_rate: sample_rate,
        ..Default::default()
    };
    
    // Check common upsampling scenarios
    let possible_original_rates = [44100, 48000, 88200, 96000];
    
    for &orig_rate in &possible_original_rates {
        if orig_rate >= sample_rate {
            continue;  // Can't be upsampled from higher rate
        }
        
        let ratio = sample_rate as f32 / orig_rate as f32;
        
        // Check if it's a clean ratio (2x, 2.18x for 44.1→96, etc.)
        let is_clean_ratio = (ratio - ratio.round()).abs() < 0.01 
            || (ratio - 2.1768).abs() < 0.01;  // 44.1→96
        
        if !is_clean_ratio {
            continue;
        }
        
        let orig_nyquist = orig_rate as f32 / 2.0;
        
        // Method 1: Spectral null
        let has_null = check_spectral_null(samples, sample_rate, orig_nyquist);
        
        // Method 2: Mirror detection
        let mirror_score = detect_nyquist_mirror(samples, sample_rate, orig_rate);
        
        // Method 3: Inter-sample peaks
        let isp_ratio = analyze_inter_sample_peaks(samples, sample_rate);
        
        // Combine evidence
        if has_null || mirror_score > 0.3 || isp_ratio < 0.4 {
            analysis.is_upsampled = true;
            analysis.original_sample_rate = Some(orig_rate);
            analysis.upsampling_ratio = Some(ratio);
            
            if has_null {
                analysis.detection_method = UpsamplingMethod::SpectralNull;
                analysis.confidence = 0.85;
            } else if mirror_score > 0.3 {
                analysis.detection_method = UpsamplingMethod::NyquistMirror;
                analysis.confidence = 0.7;
            } else {
                analysis.detection_method = UpsamplingMethod::InterpolationPattern;
                analysis.confidence = 0.6;
            }
            
            analysis.evidence.push(format!(
                "Detected upsampling from {} Hz (ratio: {:.2}x)",
                orig_rate, ratio
            ));
            
            break;
        }
    }
    
    analysis
}
```

---

## Common Upsampling Scenarios

### Standard Rate Conversions

| Original | Upsampled To | Ratio | Detection Difficulty |
|----------|-------------|-------|---------------------|
| 44.1 kHz | 88.2 kHz | 2x | Easy |
| 44.1 kHz | 96 kHz | 2.177x | Easy |
| 44.1 kHz | 176.4 kHz | 4x | Easy |
| 44.1 kHz | 192 kHz | 4.354x | Easy |
| 48 kHz | 96 kHz | 2x | Easy |
| 48 kHz | 192 kHz | 4x | Easy |
| 88.2 kHz | 176.4 kHz | 2x | Moderate |
| 96 kHz | 192 kHz | 2x | Moderate |

### Why Some Are Harder to Detect

**Easy to detect** (44.1→96kHz):
- Large frequency gap (22.05-48kHz should be empty)
- Clear spectral null visible

**Harder to detect** (96→192kHz):
- Genuine 96kHz content extends to 48kHz
- Only 48-96kHz range should be empty
- Some recordings may not have content to 48kHz anyway

---

## Limitations

### Sophisticated Resampling

Modern resamplers (SoX, iZotope) can add subtle noise or artifacts that partially mask the upsampling signature. AudioCheckr may miss these.

### Short Files

Files under 5 seconds may not provide enough data for reliable spectral analysis.

### Source Material

Some recordings legitimately don't have high-frequency content:
- Older recordings
- Heavily filtered masters
- Certain genres/instruments

### Mixed Sample Rates

Files that combine multiple sources at different sample rates are difficult to analyze.

---

## Best Practices for Detection

1. **Check the math first**: Is the sample rate a clean multiple of common rates?
2. **Look for spectral nulls**: Most reliable indicator
3. **Verify with spectrogram**: Visual inspection often clarifies ambiguous cases
4. **Consider source**: Is high-resolution content expected for this material?
5. **Use confidence scores**: Don't rely on single threshold

---

## Detection Confidence Guidelines

| Confidence | Interpretation |
|------------|----------------|
| > 0.85 | High confidence - clear spectral null |
| 0.70-0.85 | Good confidence - multiple indicators |
| 0.50-0.70 | Moderate - some evidence, verify manually |
| < 0.50 | Low - inconclusive, probably genuine |

When in doubt, generate a spectrogram and look for the characteristic "cliff" at the suspected original Nyquist frequency.
